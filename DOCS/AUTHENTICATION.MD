# üîê **SISTEMA DE AUTENTICA√á√ÉO - GUIA COMPLETO**

## üìã **VIS√ÉO GERAL**

Este projeto utiliza um sistema de autentica√ß√£o robusto baseado em **JWT (JSON Web Tokens)** para garantir a seguran√ßa das opera√ß√µes da API. O sistema trabalha em conjunto com o modelo **RBAC (Role-Based Access Control)** para fornecer controle granular de acesso.

### **Componentes Principais**
- **JWT Tokens**: Tokens de acesso para autentica√ß√£o de usu√°rios
- **BCrypt**: Hash seguro de senhas
- **OAuth2**: Padr√£o de autentica√ß√£o com senha
- **python-jose**: Biblioteca para gera√ß√£o e valida√ß√£o de tokens JWT

---

## üîÑ **FLUXO DE AUTENTICA√á√ÉO**

```mermaid
sequenceDiagram
    participant Cliente
    participant API
    participant DB
    participant JWT
    
    Cliente->>API: POST /auth/token (username, password)
    API->>DB: Buscar usu√°rio por username
    DB-->>API: Retorna dados do usu√°rio
    API->>API: Verificar senha (bcrypt)
    API->>JWT: Gerar token JWT
    JWT-->>API: Token gerado
    API-->>Cliente: {access_token, token_type}
    
    Cliente->>API: GET /users/me (Authorization: Bearer token)
    API->>JWT: Validar e decodificar token
    JWT-->>API: Dados do usu√°rio extra√≠dos
    API->>DB: Buscar usu√°rio completo
    DB-->>API: Dados do usu√°rio
    API-->>Cliente: Informa√ß√µes do usu√°rio
```

---

## üöÄ **OBTENDO UM TOKEN DE ACESSO**

### **1. Endpoint de Login**

```http
POST /auth/token
Content-Type: application/x-www-form-urlencoded

username=admin&password=senha123
```

### **2. Usando cURL**

```bash
curl -X POST "http://localhost:8000/auth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=admin&password=senha123"
```

### **3. Resposta Bem-Sucedida**

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer"
}
```

### **4. Poss√≠veis Erros**

| C√≥digo | Descri√ß√£o | Motivo |
|--------|-----------|--------|
| 400 | Bad Request | Credenciais incorretas (usu√°rio ou senha inv√°lidos) |
| 422 | Unprocessable Entity | Formato de requisi√ß√£o inv√°lido |

---

## üîë **ESTRUTURA DO TOKEN JWT**

### **Cabe√ßalho (Header)**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### **Payload (Dados)**
```json
{
  "sub": "nome_usuario",
  "exp": 1234567890,
  "nbf": 1234567890,
  "iat": 1234567890,
  "iss": "FA-Backend"
}
```

### **Campos do Payload**
| Campo | Descri√ß√£o |
|-------|-----------|
| `sub` | Subject - Nome de usu√°rio (username) |
| `exp` | Expiration Time - Data/hora de expira√ß√£o do token |
| `nbf` | Not Before - Data/hora antes da qual o token n√£o √© v√°lido |
| `iat` | Issued At - Data/hora em que o token foi emitido |
| `iss` | Issuer - Emissor do token (FA-Backend) |

### **Configura√ß√µes de Tempo**
- **Validade do Token**: Configur√°vel via `SECURITY_ACCESS_TOKEN_EXPIRE_MINUTES` (padr√£o: 30 minutos)
- **Algoritmo**: HS256 (configur√°vel via `SECURITY_ALGORITHM`)
- **Chave Secreta**: Armazenada em `.secrets/SECURITY_API_SECRET_KEY`

---

## üîí **USANDO TOKENS NAS REQUISI√á√ïES**

### **1. Incluir Token no Cabe√ßalho**

```http
GET /users/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### **2. Exemplo com cURL**

```bash
curl -X GET "http://localhost:8000/users/me" \
  -H "Authorization: Bearer SEU_TOKEN_AQUI"
```

### **3. Exemplo com Python (requests)**

```python
import requests

token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
headers = {"Authorization": f"Bearer {token}"}

response = requests.get(
    "http://localhost:8000/users/me",
    headers=headers
)
```

### **4. Exemplo com JavaScript (fetch)**

```javascript
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";

fetch("http://localhost:8000/users/me", {
  headers: {
    "Authorization": `Bearer ${token}`
  }
})
.then(response => response.json())
.then(data => console.log(data));
```

---

## üõ°Ô∏è **SEGURAN√áA DE SENHAS**

### **Hash de Senhas com BCrypt**

O sistema utiliza **BCrypt** para armazenar senhas de forma segura:

1. **Cria√ß√£o de Senha**:
   - Senha em texto plano √© recebida
   - Salt aleat√≥rio √© gerado
   - Senha √© hasheada com o salt
   - Hash √© armazenado no banco de dados

2. **Verifica√ß√£o de Senha**:
   - Usu√°rio envia senha em texto plano
   - Sistema busca hash armazenado
   - BCrypt compara senha com hash
   - Retorna verdadeiro ou falso

### **Fun√ß√µes de Seguran√ßa**

#### `get_password_hash(password: str) -> str`
```python
# Uso: Ao criar ou atualizar senha de usu√°rio
hashed = get_password_hash("senha_do_usuario")
# Retorna: "$2b$12$KIXxH9e7..."
```

#### `verify_password(plain_password: str, hashed_password: str) -> bool`
```python
# Uso: Ao validar login
is_valid = verify_password("senha_do_usuario", hashed_from_db)
# Retorna: True ou False
```

#### `create_access_token(data: dict) -> str`
```python
# Uso: Ao gerar token ap√≥s login bem-sucedido
token = create_access_token({"sub": "nome_usuario"})
# Retorna: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

#### `extract_username(jwt_token: str) -> str`
```python
# Uso: Ao validar token e extrair usu√°rio
username = extract_username(token)
# Retorna: "nome_usuario"
```

---

## üë§ **OBTENDO O USU√ÅRIO ATUAL**

### **Depend√™ncia FastAPI**

O sistema fornece uma depend√™ncia `get_current_user` para obter o usu√°rio autenticado:

```python
from app.api.authentication.controller import get_current_user
from app.models.user import User
from fastapi import Depends

@router.get("/protected-route")
async def protected_route(
    current_user: User = Depends(get_current_user)
):
    return {"username": current_user.username}
```

### **Processo de Valida√ß√£o**

1. **Extra√ß√£o do Token**: Token √© extra√≠do do cabe√ßalho `Authorization`
2. **Decodifica√ß√£o JWT**: Token √© decodificado e validado
3. **Extra√ß√£o do Username**: Campo `sub` do payload √© extra√≠do
4. **Busca no Banco**: Usu√°rio √© buscado no banco de dados
5. **Retorno**: Objeto `User` completo √© retornado

### **Exce√ß√µes Poss√≠veis**

| Exce√ß√£o | C√≥digo HTTP | Quando Ocorre |
|---------|-------------|---------------|
| `CredentialsValidationException` | 401 | Token inv√°lido, expirado ou usu√°rio n√£o encontrado |
| `IncorrectCredentialException` | 400 | Username ou senha incorretos no login |

---

## üîó **INTEGRA√á√ÉO COM RBAC**

### **Fluxo Completo: Autentica√ß√£o + Autoriza√ß√£o**

```
1. Login (Autentica√ß√£o)
   ‚Üì
2. Token JWT Gerado
   ‚Üì
3. Token em Requisi√ß√£o Protegida
   ‚Üì
4. Validar Token ‚Üí Obter Usu√°rio
   ‚Üì
5. Validar Permiss√£o (RBAC)
   ‚Üì
6. Executar Opera√ß√£o ou Negar Acesso
```

### **Valida√ß√£o de Permiss√µes**

```python
from app.api.authorization.controller import validate_transaction_access
from app.api.authentication.controller import get_current_user

@router.post("/users/create")
async def create_user(
    db_session: Session,
    current_user: User = Depends(get_current_user)
):
    # Valida se usu√°rio tem permiss√£o para criar usu√°rios
    validate_transaction_access(
        db_session, 
        current_user, 
        'OP_1040001'  # C√≥digo da opera√ß√£o "User - Create"
    )
    
    # Usu√°rio tem permiss√£o, executar opera√ß√£o...
```

### **Cadeia de Valida√ß√£o RBAC**

```
Token JWT ‚Üí User ‚Üí Assignment ‚Üí Role ‚Üí Authorization ‚Üí Transaction
```

Para mais detalhes sobre o sistema RBAC, consulte [PERMISSIONS.MD](PERMISSIONS.MD).

---

## üìù **CEN√ÅRIOS PR√ÅTICOS**

### **Cen√°rio 1: Login e Acesso a Recurso Protegido**

```bash
# 1. Fazer login e obter token
TOKEN=$(curl -s -X POST "http://localhost:8000/auth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=admin&password=senha123" \
  | jq -r '.access_token')

# 2. Usar token para acessar recurso protegido
curl -X GET "http://localhost:8000/users/me" \
  -H "Authorization: Bearer $TOKEN"
```

### **Cen√°rio 2: Token Expirado**

```bash
# Ap√≥s 30 minutos (ou tempo configurado), o token expira
curl -X GET "http://localhost:8000/users/me" \
  -H "Authorization: Bearer TOKEN_EXPIRADO"

# Resposta:
# HTTP 401 Unauthorized
# {"detail": "Could not validate credentials"}

# Solu√ß√£o: Fazer novo login e obter novo token
```

### **Cen√°rio 3: Cria√ß√£o de Usu√°rio Sem Autentica√ß√£o**

```bash
# Este √© o √öNICO endpoint que n√£o requer autentica√ß√£o
curl -X POST "http://localhost:8000/users/" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "novo_usuario",
    "display_name": "Novo Usu√°rio",
    "email": "novo@email.com",
    "password": "senha123"
  }'

# ‚ö†Ô∏è IMPORTANTE: Usu√°rio criado n√£o tem nenhuma permiss√£o
# Um admin precisa atribuir um Role via Assignment
```

### **Cen√°rio 4: Tentativa de Acesso Sem Token**

```bash
curl -X GET "http://localhost:8000/users/"

# Resposta:
# HTTP 401 Unauthorized
# {"detail": "Not authenticated"}
```

---

## ‚öôÔ∏è **CONFIGURA√á√ÉO DO SISTEMA**

### **Vari√°veis de Ambiente (.env)**

```plaintext
# Algoritmo de criptografia JWT
SECURITY_ALGORITHM=HS256

# Tempo de expira√ß√£o do token em minutos
SECURITY_ACCESS_TOKEN_EXPIRE_MINUTES=30

# URL do banco de dados
DB_URL=sqlite:///database.db
```

### **Chave Secreta (.secrets/SECURITY_API_SECRET_KEY)**

```bash
# Gerar chave secreta forte
openssl rand -hex 32 > .secrets/SECURITY_API_SECRET_KEY

# Ou usar Python
python -c "import secrets; print(secrets.token_hex(32))" > .secrets/SECURITY_API_SECRET_KEY
```

‚ö†Ô∏è **IMPORTANTE**: 
- NUNCA commite a chave secreta no reposit√≥rio
- Use uma chave diferente para produ√ß√£o
- Mantenha a chave em local seguro

---

## üîç **ARQUITETURA DO C√ìDIGO**

### **Estrutura de Arquivos**

```
app/api/authentication/
‚îú‚îÄ‚îÄ router.py          # Endpoint de login (/auth/token)
‚îú‚îÄ‚îÄ controller.py      # L√≥gica de autentica√ß√£o (login, valida√ß√£o)
‚îî‚îÄ‚îÄ schemas.py         # Modelos Pydantic (AccessToken, TokenData)

app/utils/
‚îú‚îÄ‚îÄ security.py        # Fun√ß√µes de seguran√ßa (JWT, hash)
‚îî‚îÄ‚îÄ settings.py        # Configura√ß√µes da aplica√ß√£o
```

### **Fluxo de C√≥digo**

1. **Router** (`router.py`):
   - Define endpoint `/auth/token`
   - Recebe credenciais via `OAuth2PasswordRequestForm`
   - Chama controller para processar login

2. **Controller** (`controller.py`):
   - `execute_user_login()`: Valida credenciais e gera token
   - `get_current_user()`: Extrai e valida usu√°rio do token
   - Usa fun√ß√µes de `security.py` para opera√ß√µes criptogr√°ficas

3. **Security** (`security.py`):
   - `create_access_token()`: Gera token JWT
   - `verify_password()`: Valida senha com bcrypt
   - `get_password_hash()`: Hash de senha para armazenamento
   - `extract_username()`: Extrai username do token

---

## üß™ **TESTANDO O SISTEMA**

### **Teste Manual via Swagger UI**

1. Acesse: http://localhost:8000/api/v1/docs
2. V√° at√© o endpoint `/auth/token`
3. Clique em "Try it out"
4. Preencha username e password
5. Clique em "Execute"
6. Copie o `access_token` retornado
7. Clique no bot√£o "Authorize" (cadeado) no topo da p√°gina
8. Cole o token no campo "Value"
9. Clique em "Authorize"
10. Agora voc√™ pode testar endpoints protegidos

### **Teste com pytest**

```bash
# Executar todos os testes
pytest tests/

# Executar testes de autentica√ß√£o espec√≠ficos
pytest tests/ -k "auth"

# Com cobertura
pytest --cov=app tests/
```

---

## üö® **SEGURAN√áA E BOAS PR√ÅTICAS**

### ‚úÖ **O Sistema Implementa**
- Hash seguro de senhas com BCrypt e salt aleat√≥rio
- Tokens JWT com expira√ß√£o configur√°vel
- Valida√ß√£o de token em toda requisi√ß√£o protegida
- Chave secreta armazenada fora do c√≥digo
- OAuth2 password flow padr√£o
- Timestamps completos em tokens (iat, nbf, exp)

### ‚ö†Ô∏è **Recomenda√ß√µes**
- Use HTTPS em produ√ß√£o (nunca HTTP)
- Rotacione a chave secreta periodicamente
- Configure tempo de expira√ß√£o adequado (nem muito curto, nem muito longo)
- Implemente refresh tokens para melhor experi√™ncia do usu√°rio
- Use rate limiting para prevenir ataques de for√ßa bruta
- Monitore tentativas de login falhadas
- Implemente logout do lado do servidor (blacklist de tokens)

### üõ°Ô∏è **Prote√ß√µes Contra Ataques**
- **For√ßa Bruta**: Senhas hasheadas com BCrypt (lento por design)
- **Token Replay**: Tokens expiram ap√≥s tempo configurado
- **Token Forgery**: Assinatura HMAC-SHA256 com chave secreta
- **SQL Injection**: SQLAlchemy ORM com queries parametrizadas
- **XSS**: FastAPI serializa automaticamente respostas JSON

---

## üìö **REFER√äNCIAS**

### **Documenta√ß√£o Relacionada**
- [PERMISSIONS.MD](PERMISSIONS.MD) - Sistema de permiss√µes RBAC
- [FLUXOGRAMA.MD](FLUXOGRAMA.MD) - Fluxo geral da aplica√ß√£o
- [README.MD](../README.MD) - Documenta√ß√£o principal do projeto

### **Bibliotecas Utilizadas**
- [FastAPI Security](https://fastapi.tiangolo.com/tutorial/security/)
- [python-jose](https://python-jose.readthedocs.io/)
- [bcrypt](https://pypi.org/project/bcrypt/)
- [OAuth2 Specification](https://oauth.net/2/)
- [JWT.io](https://jwt.io/) - Decoder de tokens JWT

### **Especifica√ß√µes**
- [RFC 7519 - JWT](https://datatracker.ietf.org/doc/html/rfc7519)
- [RFC 6749 - OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc6749)
- [BCrypt Algorithm](https://en.wikipedia.org/wiki/Bcrypt)

---

## üí° **PERGUNTAS FREQUENTES**

### **1. Quanto tempo o token dura?**
Por padr√£o, 30 minutos. Configur√°vel via `SECURITY_ACCESS_TOKEN_EXPIRE_MINUTES` no `.env`.

### **2. O que acontece quando o token expira?**
O usu√°rio recebe um erro 401 e precisa fazer login novamente para obter um novo token.

### **3. Posso ter m√∫ltiplos tokens ativos?**
Sim, cada login gera um novo token. Todos permanecem v√°lidos at√© expirarem.

### **4. Como fa√ßo logout?**
Atualmente, o logout √© feito no lado do cliente (descartando o token). Para logout do servidor, seria necess√°rio implementar uma blacklist de tokens.

### **5. Posso renovar um token sem fazer login novamente?**
N√£o, atualmente. Para implementar isso, seria necess√°rio adicionar refresh tokens ao sistema.

### **6. Qual a diferen√ßa entre autentica√ß√£o e autoriza√ß√£o?**
- **Autentica√ß√£o**: Verifica QUEM voc√™ √© (login com usu√°rio/senha, valida√ß√£o de token)
- **Autoriza√ß√£o**: Verifica O QUE voc√™ pode fazer (permiss√µes via RBAC)

### **7. Por que BCrypt ao inv√©s de SHA256?**
BCrypt √© especificamente projetado para senhas, sendo intencionalmente lento para dificultar ataques de for√ßa bruta, al√©m de incluir salt automaticamente.

### **8. O token pode ser decodificado por qualquer um?**
O token pode ser decodificado (payload √© base64), mas n√£o pode ser MODIFICADO sem a chave secreta. A assinatura garante que o token n√£o foi adulterado.

---

## üìû **SUPORTE**

Para d√∫vidas ou problemas com autentica√ß√£o:
- Abra uma issue no GitHub
- Consulte a documenta√ß√£o do FastAPI
- Revise os logs da aplica√ß√£o
- Verifique as configura√ß√µes do `.env` e `.secrets`

---

**√öltima atualiza√ß√£o**: Dezembro 2024  
**Vers√£o da Documenta√ß√£o**: 1.0
